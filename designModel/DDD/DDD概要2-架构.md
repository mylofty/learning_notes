[toc]

# 软件设计原则
1. 单一性原则（Single Responsibility Principle）：单一性原则要求一个对象/类应该只有一个变更的原因。但是在这个案例里，代码可能会因为任意一个外部依赖或计算逻辑的改变而改变。
2. 依赖反转原则（Dependency Inversion Principle）：依赖反转原则要求在代码中依赖抽象，而不是具体的实现。在这个案例里外部依赖都是具体的实现，比如YahooForexService虽然是一个接口类，但是它对应的是依赖了Yahoo提供的具体服务，所以也算是依赖了实现。同样的KafkaTemplate、MyBatis的DAO实现都属于具体实现。
3. 开放封闭原则（Open Closed Principle）：开放封闭原则指开放扩展，但是封闭修改。在这个案例里的金额计算属于可能会被修改的代码，这个时候该逻辑应该需要被包装成为不可修改的计算类，新功能通过计算类的拓展实现。

# 概念
## 事物脚本
把整个业务逻辑跟写脚本一样在一个函数中记流水账，函数包括参数校验，数据读取，业务计算，调用外部服务，发送消息等操作。缺点：可维护性差，可扩展性差，可测试性差。原因：外部依赖函数签名可能发生变化，外部依赖可能切换接口，数据可能分片。在事务脚本式的架构下，一般做第一个需求都非常的快，但是做第N个需求时需要的时间很有可能是呈指数级上升的，绝大部分时间花费在老功能的重构和兼容上，最终你的创新速度会跌为0，促使老应用被推翻重构。
## 数据库的抽象
### 1. 实体Entity和data object（DO）数据类
DO是数据库中表的映射，DO只有数据，没有行为，DO可以完全映射到数据库上，但代码中应该避免直接操作DO。Entity是领域逻辑中的实体类，不需要跟数据库有必然的联系，包括数据，也包括行为。比如DO和数据库中有一个string类型的列，在entity中，可以用一个对象来代替这个string，然后对象中封装一些校验等操作
### 2. DAO和Repository类的对比
DAO对应的是具体数据库类型的操作，操作DO类，行为为对SQL封装。Repository接口对应的是对Entity对象操作的抽象。具体实现类为通过DAO实现各种DO操作，然后通过工厂/单例将DO和Entity转化
### 3. Entity和Repository
Entiry对象避免了和数据库直接耦合，防止数据库变化，大量业务逻辑要跟着变化
通过Repository接口类，让业务逻辑不面向数据库编程，而是面向领域模型编程
Repository接口类的具体实现类xxxrepositoryImpl，职责被单一出来，只需关注entity到DO的映射关系和repository和DAO方法的映射关系，容易测试
## 抽象第三方服务
防腐层。避免对外部服务产生强依赖，由于外部服务的不合理的技术实现，腐蚀我们的系统。通过增加一个防腐层（anti-corruption layer, ACL)来进行隔离外部依赖，该层可以增加如下功能：
适配器：将转化逻辑封装到ACL内部，避免外部代码侵入，使结构更符合我们的预期
缓存：避免频繁外部依赖，ACL嵌入缓存逻辑，降低外部依赖的请求压力，也不用写到业务代码中，降低代码复杂度
兜底：外部的bug，能在ACL层兜底
易于修改测试，容易mock和stub，便于单元测试
功能开关，配置功能开关，不需要该外部接口时候，返回固定值